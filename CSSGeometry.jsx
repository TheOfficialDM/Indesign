//// CSSGeometry.jsx//// Version 0.0.5//// (C) 2011-2012 Rorohiko Ltd.// All rights reserved.// By Kris Coppieters// kris@rorohiko.com////// How it works://// This is an InDesign script (tested with CS5 or higher); it needs to be // installed into the Adobe InDesign CS5/Scripts/Scripts Panel folder// or the user's script folder.//// Double-click the CSSGeometry.jsx entry on the Scripts Palette // to activate the script. The script will scan the active document// and find all frames (excluding frames on the pasteboard and on// master pages). Then it will generate CSS positioning info for each// of the frames.//// To make the script work better, you can assign Script Labels // (Window - Utilities - Script Labels menu item) to individual frames.//// Script labels on the frames can be used in two ways. If you assign a // script label////	 ignore// // to a frame, it'll be omitted from the CSS.//// If you assign a script label that starts with a '#' (e.g.////	 #MyItem//// ) then it will use that for the CSS id instead of the generated #p3-2 kind.//// If a page has only one frame, the id of the first (single) frame is of // the form '#p3'. If there are multiple frames, the id of the first // frame (of multiple)	is of the form '#p3-1'.//// The text frame on the pasteboard that is created to contain the CSS is re-used // when you run the script a second, third, fourth… time. You're allowed to delete// it after use; the script will re-create it if it cannot find it. The script // identifies this pasteboard text frame by its script label - GeneratedCSSFrame//// That means you can reposition the GeneratedCSSFrame and it'll keep on updating // each time you run the script. Works great iteratively: move a few frames around,// run the script. Need to modify something? Tweak a few frames, run the script. // Tweak, run. Rinse, repeat. //// The script can be customized by changing the configuration section (wedged // between *** CONFIG START *** and *** CONFIG END *** further down).//// For debugging://// To de-instrument (comment LogEntry/LogExit): do a global find change and// replace pattern		 /**///		 with pattern	 /**///// To instrument (uncomment LogEntry/LogExit): do a global find change and// replace pattern		 /**///		 with pattern	 /**/////var gErr;var gScriptFile;var gCaches;try{	if (app.activeScript instanceof File)	{		var gScriptFile = app.activeScript;	}}catch (gErr){}if (typeof(kLogLevel) == "undefined"){	const kLogLevel = 5;	const kMaxLogNestLevel = 5;	const kLogToMessageBox = false;	const kLogToConsole = false;	const kLogToFile = false;	const kLogFileName = "CSSGeometry.log";//// You can configure how the script works by modifying the information between the CONFIG START// and CONFIG END lines. Change a setting to 1 to turn it on, and to 0 to turn it off.// E.g. f you want to ignore image frames (and have the script only process text frames) // change the line further below to read kIgnoreImageFrames = 1;//// *** CONFIG START ***	const kIgnoreImageFrames = 0;	const kIgnoreTextFrames = 0;	const kUsePercentageInsteadOfPixels = 0;	const kIgnoreFrameLabel = "ignore";	const kIdentifierPrefix = "#p";	const kIdentifierInfix = "-";	const kCSSFrameLabel = "GeneratedCSSFrame";	const kLeftPageGeneratedCSSIdSuffix = "L";	const kMiddlePageGeneratedCSSIdSuffix = "M";	const kRightPageGeneratedCSSIdSuffix = "R";	const kCreateCompactCSS = 0;// *** CONFIG END ***}var gRunState ={	logToMessageBox: kLogToMessageBox,	logToConsole: kLogToConsole,	logToFile: kLogToFile,	functionNestLevel: 0,	logFunctionEntry: true,	logFunctionExit: true,	logLevel: kLogLevel,	logFileName: kLogFileName};Main();// ****************function CollectionToArray(theCollection){	/**///LogEntry("CollectionToArray");		var retVal = theCollection.everyItem().getElements().slice(0);		/**///LogExit("CollectionToArray");		return retVal;} // ****************//// Sorts by ascending page, then ascending y-pos, then ascending x-pos, then ascending width//function CompareFrameReferences(frameReferenceA, frameReferenceB){	/**///LogEntry("CompareFrameReferences");		var result;	do 	{		result = frameReferenceA.page - frameReferenceB.page;		if (result != 0)		{			break;		}				result = frameReferenceA.y - frameReferenceB.y;		if (result != 0)		{			break;		}				result = frameReferenceA.x - frameReferenceB.x;		if (result != 0)		{			break;		}				result = frameReferenceA.w - frameReferenceB.w;		if (result != 0)		{			break;		}	}	while (false);  	/**///LogExit("CompareFrameReferences");	return result;}// ****************function CreateFrameReferences(doc, frame){	/**///LogEntry("CreateFrameReference");	var frameReferences = null;	do 	{		if (! (doc instanceof Document)) 		{			LogError("CreateFrameReferences: doc should be a Document");			break;		}				/*		* Ignore stuff on pasteboard: pasteboard items don't have a parentPage		*/		var parentPage = frame.parentPage;		if (! (parentPage instanceof Page))		{			break;		}				/*		* Ignore stuff on master page - master spread items have a parent page whose 		* parent is a MasterSpread instead of a Spread		*/		var parentSpread = parentPage.parent;		if (! (parentSpread instanceof Spread))		{			break;		}				var identifier = frame.label;		if (identifier.toLowerCase() == kIgnoreFrameLabel)		{			break;		}			if (identifier == null || identifier.charAt(0) != '#')		{			identifier = null;		}		var parentPages = GetParentPages(frame);		var frameRect = frame.geometricBounds.slice(0);		var parentFrameReference = null;		for (var pageIdx = 0; pageIdx < parentPages.length; pageIdx++) 		{			var parentPage = parentPages[pageIdx];			var overlapRect = GetOverlapRect(parentPage, frame);			var insets = [ 0, 0, 0, 0 ];			if (frame instanceof TextFrame)			{				insets = frame.textFramePreferences.insetSpacing;				if ((typeof insets) == "number") 				{					insets = [ insets, insets, insets, insets ];				};				//				// Ignore insets that sit on other pages. There are				// 'borderline' cases where the overlap ends up smaller than the				// inset.				// We simply pretend those don't exist - if it happens, well, it happens				// 				if (frameRect[0] < overlapRect[0]) 				{					insets[0] = 0;				}				if (frameRect[1] < overlapRect[1]) 				{					insets[1] = 0;				}				if (frameRect[2] > overlapRect[2]) 				{					insets[2] = 0;				}				if (frameRect[3] > overlapRect[3]) 				{					insets[3] = 0;				}			}			var frameReference = 			{				frame: frame,				parentPage: parentPage,				page: parentPage.documentOffset + 1,				frameOverlapPageCount: parentPages.length,				x: Round(overlapRect[1] + insets[1]),				y: Round(overlapRect[0] + insets[0]),				w: Round(overlapRect[3] - insets[3] - overlapRect[1] - insets[1])			}			if (parentPages.length == 1) 			{				frameReference.identifier = identifier;			}			else if (parentFrameReference == null) 			{				frameReference.frameOverlapIdx = 1;				frameReference.identifier = identifier;				parentFrameReference = frameReference;			}			else			{				frameReference.frameOverlapIdx = (pageIdx + 1);				frameReference.identifier = null;				frameReference.parentFrameReference = parentFrameReference;			}			if (frameReferences == null) 			{				frameReferences = [];			}			frameReferences.push(frameReference);		}						}	while (false);			/**///LogExit("CreateFrameReferences");		return frameReferences;}// ****************function GetOverlapRect(page, pageItem) {	/**///LogEntry("GetOverlapRect");	var overlapBounds = null;	try 	{		do 		{			if (! IsOnPage(page,pageItem)) 			{				break;			}			overlapBounds = pageItem.geometricBounds.slice(0);			var pageBounds = page.bounds.slice(0);			if (overlapBounds[0] < pageBounds[0]) 			{				overlapBounds[0] = pageBounds[0];			}			if (overlapBounds[1] < pageBounds[1]) 			{				overlapBounds[1]  = pageBounds[1];			}			if (overlapBounds[2] > pageBounds[2]) 			{				overlapBounds[2] = pageBounds[2];			}			if (overlapBounds[3] > pageBounds[3]) 			{				overlapBounds[3] = pageBounds[3];			}			overlapBounds[0] -= pageBounds[0];			overlapBounds[1] -= pageBounds[1];			overlapBounds[2] -= pageBounds[0];			overlapBounds[3] -= pageBounds[1];		}		while (false);	}	catch (gErr) 	{	}	/**///LogExit("GetOverlapRect");	return overlapBounds;}// ****************function GetParentPages(pageItem) {	/**///LogEntry("GetParentPages");		var parentPages = [];	try 	{		var pageItemParent = pageItem.parent;		if (pageItemParent instanceof Spread) 		{			var spread = pageItemParent;			var spreadPages = CollectionToArray(spread.pages);			for (var pageIdx = 0; pageIdx < spreadPages.length; pageIdx++) 			{				var page = spreadPages[pageIdx];				if (IsOnPage(page,pageItem)) 				{					parentPages.push(page);				}			}		}		if (parentPages.length > 1) 		{			// Sort in proper order, just in case			parentPages.sort(function(pg1,pg2){ return pg1.documentOffset - pg2.documentOffset; });		}	}	catch (gErr) 	{	}		/**///LogExit("GetParentPages");	return parentPages;}// ****************function GetParentSpread(pageItem) {	/**///LogEntry("GetParentSpread");		var parent = null;	try 	{		var prvParent = null;		parent = pageItem;		while (parent != null && parent != prvParent && ! (parent instanceof Spread)) 		{			parent = parent.parent;		}		if (! (parent instanceof Spread)) 		{			parent = null;		}	}	catch (gErr) 	{	}		/**///LogExit("GetParentSpread");	return parent;}// ****************function IsOnPage(page, pageItem){	/**///LogEntry("IsOnPage"); 		var overlaps = false;	do 	{		 		if (GetParentSpread(page) != GetParentSpread(pageItem)) 		{			break;		}			var itemBounds = pageItem.geometricBounds.slice(0);		var pageBounds = page.bounds.slice(0);		if (itemBounds[1] - pageBounds[3] > -0.1) 		{			break;		}		if (itemBounds[0] - pageBounds[2] > -0.1) 		{			break;		}		if (itemBounds[3] - pageBounds[1] < 0.1) 		{			break;		}		if (itemBounds[2] - pageBounds[0] < 0.1) 		{			break;		}		overlaps = true;	}	while (false);		/**///LogExit("IsOnPage");		return overlaps;} // ****************function LogMessage(message,collapseLines){	if (gRunState.logToConsole)	{		$.writeln(message);	}	if (gRunState.logToFile)	{		var logFile = new File(gScriptFile.parent + "/" + gRunState.logFileName);		var now = new Date();		logFile.open("a");		logFile.write(now.toString() + ": " + message + "\n");		logFile.close();	}	if (gRunState.logToMessageBox)	{		alert(message);	}}// ****************function LogEntry(message){	if (gRunState.logFunctionEntry)	{		if (gRunState.functionNestLevel < kMaxLogNestLevel) {			for (var idx = 0; idx < gRunState.functionNestLevel; idx++)			{				message = "	 " + message;			}			LogNote(message + "<",true);		}	}	gRunState.functionNestLevel++;}// ****************function LogError(message){	if (gRunState.logLevel >= 1)	{		LogMessage("***ERROR***: "+message,false);	}}// ****************function LogExit(message){	gRunState.functionNestLevel--;	if (gRunState.functionNestLevel < 0)	{		LogError("LogExit: unbalanced function nesting");	}	if (gRunState.logFunctionExit)	{		if (gRunState.functionNestLevel < kMaxLogNestLevel) {			for (var idx = 0; idx < gRunState.functionNestLevel; idx++)			{				message = "	 " + message;			}			LogNote(message + ">",true);		}	}}// ****************function LogNote(message){	if (gRunState.logLevel >= 3)	{		LogMessage("Note: "+message,false);	}}// ****************function LogWarning(message){	if (gRunState.logLevel >= 2)	{		LogMessage("WARNING: "+message,false);	}}// ****************function Main(){	/**///LogEntry("Main");		gCaches = null;		var savedUserInteractionLevel = app.scriptPreferences.userInteractionLevel;	app.scriptPreferences.userInteractionLevel = UserInteractionLevels.NEVER_INTERACT;		do 	{		try 		{			var activeDocument = app.activeDocument;			if (! (activeDocument instanceof Document)) 			{				LogError("Main: activeDocument is not a Document");				break;			}						var savedHorizontalMeasurementUnits = activeDocument.viewPreferences.horizontalMeasurementUnits;			activeDocument.viewPreferences.horizontalMeasurementUnits = MeasurementUnits.PIXELS;			var savedVerticalMeasurementUnits = activeDocument.viewPreferences.verticalMeasurementUnits;			activeDocument.viewPreferences.verticalMeasurementUnits = MeasurementUnits.PIXELS;			var savedRulerOrigin = activeDocument.viewPreferences.rulerOrigin;			do 			{				try 				{					ProcessFrames(activeDocument);				}				catch (gErr) 				{					alert("The script encountered a situation it does not know how to handle. The error it received into says '" + gErr + "' in Main()");				}			}			while (false);			activeDocument.viewPreferences.rulerOrigin = savedRulerOrigin;			activeDocument.viewPreferences.horizontalMeasurementUnits = savedHorizontalMeasurementUnits;			activeDocument.viewPreferences.verticalMeasurementUnits = savedVerticalMeasurementUnits;		}		catch (gErr)		{			alert("The script encountered a situation it does not know how to handle. The error it received into says '" + gErr + "' in Main()");			LogError("Main throws " + gErr);		}	}	while (false);	app.scriptPreferences.userInteractionLevel = savedUserInteractionLevel;	/**///LogExit("Main");}// ****************function ProcessFrames(doc){	/**///LogEntry("ProcessFrames");	do 	{		if (! (doc instanceof Document)) 		{		  LogError("ProcessFrames: doc should be a Document");		  break;		}				var allFrames = CollectionToArray(doc.pageItems);		var frames = [];		for (var frameIdx = 0; frameIdx < allFrames.length; frameIdx++) {			var frame = Upcast(allFrames[frameIdx]);						if (frame instanceof TextFrame) {				if (! kIgnoreTextFrames) {					frames.push(frame);				}			}						else if (frame instanceof Rectangle || frame instanceof Oval || frame instanceof Polygon) {				if (! kIgnoreImageFrames) {					frames.push(frame);				}			}					}				var frameReferences = [];		var cssTextFrame = null;		doc.viewPreferences.rulerOrigin = RulerOrigin.SPREAD_ORIGIN;		for (var frameIdx = 0; frameIdx < frames.length; frameIdx++)		{			var frame = frames[frameIdx];			if (frame instanceof TextFrame && frame.label == kCSSFrameLabel)			{				/*				* Once we have a dummy frame on the pasteboard for the CSS, we re-use it.				* We can recognize it by its script label				*/				cssTextFrame = frame;			}			var addReferences = CreateFrameReferences(doc, frame);			if (addReferences != null)			{				frameReferences = frameReferences.concat(addReferences);			}		}				/*		* Sort by page, then ypos, then xpos, then width - so the text frames are in a sensible sequence		*/		frameReferences.sort(CompareFrameReferences);				/*		* Create CSS identifiers for frames that have no identifier yet		*/		var curPage = null;		var frameSequenceOnPage = 0;		var firstFrameReferenceOnPage = null;		for (var frameReferenceIdx = 0; frameReferenceIdx < frameReferences.length; frameReferenceIdx++)		{			var frameReference = frameReferences[frameReferenceIdx];			if (frameReference.identifier == null && frameReference.parentFrameReference == null)			{				/*				* Reset the page item sequencing counter to 0 each time we go to a next page				*/				if (curPage != frameReference.page)				{					frameSequenceOnPage = 0;					curPage = frameReference.page;				}				frameSequenceOnPage++;				var identifier;				if (frameSequenceOnPage == 1)				{					/*					* Initially don't include a -1 suffix. If it turns out there are multiple frames, we'll add it 					*/					identifier = kIdentifierPrefix + frameReference.page;					firstFrameReferenceOnPage = frameReference;				}				else 				{					if (frameSequenceOnPage == 2)					{						/*						* When we find a second frame on a page, we hark back to the first frame on the page and adjust its identifier to include "-1" at the end						*/						firstFrameReferenceOnPage.identifier = kIdentifierPrefix + firstFrameReferenceOnPage.page + kIdentifierInfix + 1;					}					identifier = kIdentifierPrefix + frameReference.page + kIdentifierInfix + frameSequenceOnPage;				}				frameReference.identifier = identifier;			}		}				/*		* Add suffixes for items that sit across multiple pages		* 2 page spreads: use suffixes "L" and "R" (default)		* 3 page spreads: use suffixes "L", "M" and "R" (default)		* > 3 page spreads: use numerical suffixes		*/		for (var frameReferenceIdx = 0; frameReferenceIdx < frameReferences.length; frameReferenceIdx++)		{			var frameReference = frameReferences[frameReferenceIdx];			var parentFrameReference = frameReference.parentFrameReference;			if (frameReference.identifier == null && parentFrameReference != null)			{				if (parentFrameReference.frameOverlapPageCount == 2) 				{					frameReference.identifier = parentFrameReference.identifier + kRightPageGeneratedCSSIdSuffix;				}				else if (parentFrameReference.frameOverlapPageCount == 3)				{					if (frameReference.frameOverlapIdx == 2)					{						frameReference.identifier = parentFrameReference.identifier + kMiddlePageGeneratedCSSIdSuffix;					}					else					{						frameReference.identifier = parentFrameReference.identifier + kRightPageGeneratedCSSIdSuffix;					}				}				else				{					frameReference.identifier = parentFrameReference.identifier + frameReference.frameOverlapIdx;				}			}		}		for (var frameReferenceIdx = 0; frameReferenceIdx < frameReferences.length; frameReferenceIdx++)		{			var frameReference = frameReferences[frameReferenceIdx];			if (frameReference.frameOverlapIdx == 1)			{				if (frameReference.frameOverlapPageCount == 2) 				{					frameReference.identifier = frameReference.identifier + kLeftPageGeneratedCSSIdSuffix;				}				else if (frameReference.frameOverlapPageCount == 3)				{					frameReference.identifier = parentFrameReference.identifier + kLeftPageGeneratedCSSIdSuffix;				}				else				{					frameReference.identifier = frameReference.identifier + "1";				}			}		}			var cssText = "";		doc.viewPreferences.rulerOrigin = RulerOrigin.PAGE_ORIGIN;		for (var frameReferenceIdx = 0; frameReferenceIdx < frameReferences.length; frameReferenceIdx++)		{			var frameReference = frameReferences[frameReferenceIdx];			var top;			var left;			var width;			if (kUsePercentageInsteadOfPixels)			{				var parentPage = frameReference.parentPage;				var pageWidth = parentPage.bounds[3] - parentPage.bounds[1];				var pageHeight = parentPage.bounds[2] - parentPage.bounds[0];				top = Math.round(frameReference.y / pageWidth * 100) + "%";				left = Math.round(frameReference.x / pageWidth * 100) + "%";				width = Math.round(frameReference.w / pageWidth * 100) + "%";			}			else			{				top = frameReference.y + "px";				left = frameReference.x + "px";				width = frameReference.w + "px";			}			var separator = kCreateCompactCSS ? " " : "\n";			var cssLine = frameReference.identifier + 				"{" + separator + 				(kCreateCompactCSS ? 					"" : 					(" /* Page " + frameReference.page + ", " + ((frameReference.frame instanceof TextFrame) ? "Text" : "Graphic") + " */ ")) + separator +				" position: absolute;" + separator +				" top: " + top + ";" + separator +				" left: " + left + ";" + separator +				" width: " + width + ";" + separator +				"}\n";			cssText += cssLine;		}		/*		* Create a frame on the pasteboard on page 1 if none exists yet (from previous runs)		*/		if (cssTextFrame == null)		{			var pageOne = doc.pages.item(0);			var pageWidth = pageOne.bounds[3] - pageOne.bounds[1];			var pageHeight = pageOne.bounds[2] - pageOne.bounds[0];			cssTextFrame = doc.pages.item(0).textFrames.add();			cssTextFrame.label = kCSSFrameLabel;			cssTextFrame.geometricBounds = [0, -pageWidth / 2, pageHeight, -2 ];		}			cssTextFrame.parentStory.contents = cssText;	}	while (false);			/**///LogExit("ProcessFrames");}// ****************function Round(numVal){	/**///LogEntry("Round");	var retVal = Math.round(numVal);	/**///LogExit("Round");		return retVal;}// ****************// Sometimes InDesign hands us a bland PageItem, which cuts us off from // accessing item-specific data (e.g. the content of a text frame).// This routine converts a PageItem reference to something more specific// so we can access the specific data for the page itemfunction Upcast(pageItem){	/**///LogEntry("Upcast");	var retVal = pageItem;	try {		retVal = pageItem.getElements()[0];	}	catch (gErr) {		retVal = pageItem;	}	/**///LogExit("Upcast");		return retVal;}