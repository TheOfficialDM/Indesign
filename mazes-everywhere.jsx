//DESCRIPTION:Mazes Everywhere!// A Jongware Script 17-Sep-2010// Change this to true to see where nested paths fail ...seePathWinding = false;app.activeDocument.viewPreferences.horizontalMeasurementUnits = MeasurementUnits.MILLIMETERS;app.activeDocument.viewPreferences.verticalMeasurementUnits = MeasurementUnits.MILLIMETERS;drawInsideSomething = false;if (app.selection.length == 1 && app.selection[0].hasOwnProperty("paths")){	drawInsideSomething = true;	app.selection[0].paths.everyItem().pathPoints.everyItem().pointType = PointType.LINE_TYPE;	xoff = app.selection[0].geometricBounds[1];	yoff = app.selection[0].geometricBounds[0];	rectwidth = app.selection[0].geometricBounds[3] - app.selection[0].geometricBounds[1];	rectheight = app.selection[0].geometricBounds[2] - app.selection[0].geometricBounds[0];	mazeWidth = Math.floor(rectwidth/5);	mazeHeight = Math.floor(rectheight/5);		xoff += (rectwidth-5*mazeWidth)/2;	yoff += (rectheight-5*mazeHeight)/2;} else{	mazeDlg = app.dialogs.add ({name:"Maze Size",canCancel:true});	with (mazeDlg)	{		with (dialogColumns.add())		{			with (dialogRows.add())				staticTexts.add ({staticLabel:"Width"});			with (dialogRows.add())				wBox = integerEditboxes.add({editContents:"20"});			with (dialogRows.add())				staticTexts.add ({staticLabel:"Height"});			with (dialogRows.add())				hBox = integerEditboxes.add({editContents:"20"});		}	}	if (!mazeDlg.show())	{		mazeDlg.destroy();		exit(0);	}	mazeWidth = wBox.editValue;	mazeHeight = hBox.editValue;	xoff = (app.activeDocument.documentPreferences.pageWidth - 5*mazeWidth)/2;	yoff = (app.activeDocument.documentPreferences.pageHeight - 5*mazeHeight)/2;;}maze = new Array(mazeHeight);if (drawInsideSomething){	triedAgain = false;	for (y=0; y<mazeHeight; y++)	{		maze[y] = new Array(mazeWidth);		for (x=0; x<mazeWidth; x++)		{			maze[y][x] = true;		}	}		while (1)	{		for (p=0; p<app.selection[0].paths.length; p++)		{			a_path = app.selection[0].paths[p].entirePath;			a = a_path[a_path.length-1][0]*a_path[0][1] - a_path[a_path.length-1][1]*a_path[0][0];			for (pp=0; pp<a_path.length-1; pp++)			{				a += (a_path[pp][0]*a_path[pp+1][1] - a_path[pp+1][1]*a_path[pp][0]);			}			winding = (a < 0) ? true : false;		//	alert ("path: "+p+" = "+winding+"; "+a_path.join("  "));			for (y=0; y<mazeHeight; y++)			{				for (x=0; x<mazeWidth; x++)				{					pt = [ xoff+5*x+2.5, yoff+5*y+2.5 ];					if (pointInside (pt, a_path))					{						maze[y][x] = winding;						if (seePathWinding)							app.activeDocument.rectangles.add({geometricBounds:[yoff+5*y+1, xoff+5*x+1, yoff+5*(y+1)-1, xoff+5*(x+1)-1 ], fillColor:app.activeDocument.swatches[2], fillTint:winding ? 10 : 50 } );					}				}			}		}		foundAny = false;		for (y=0; y<mazeHeight; y++)		{			for (x=0; x<mazeWidth; x++)			{				if (!maze[y][x])				{					foundAny = true;					break;				}			}		}		if (foundAny)			break;		if (triedAgain)		{			alert ("No valid paths found! Check the path winding order...");			exit(0);		}		triedAgain = true;		app.selection[0].paths.everyItem().reverse();	}} else{	for (y=0; y<mazeHeight; y++)	{		maze[y] = new Array(mazeWidth);		for (x=0; x<mazeWidth; x++)		{			maze[y][x] = false;		}	}}do{	posx = Math.floor(Math.random()*mazeWidth);	posy = Math.floor(Math.random()*mazeHeight);	if (!maze[posy][posx])		break;} while (1);maze[posy][posx] = true;validcells = [];while (1){	validdir = [];	if (posy > 0 && !maze[posy-1][posx])		validdir.push (1);	if (posy < mazeHeight-1 && !maze[posy+1][posx])		validdir.push (2);	if (posx > 0 && !maze[posy][posx-1])		validdir.push (4);	if (posx < mazeWidth-1 && !maze[posy][posx+1])		validdir.push (8);	if (validdir.length == 0)	{		if (validcells.length > 0)		{			x = validcells.pop();			posx = x[0];			posy = x[1];			continue;		}		break;	}	if (validdir.length == 1)		newdir = validdir[0];	else	{		newdir = validdir[Math.floor(Math.random()*validdir.length)];		validcells.push ([posx,posy]);	}	switch (newdir)	{		case 1:			app.activeDocument.rectangles.add({geometricBounds:[yoff+5*posy-4, xoff+5*posx+1, yoff+5*(posy+1)-1, xoff+5*(posx+1)-1 ], fillColor:app.activeDocument.swatches[2] } );			posy--;			break;		case 2:			app.activeDocument.rectangles.add({geometricBounds:[yoff+5*posy+1, xoff+5*posx+1, yoff+5*(posy+1)+4, xoff+5*(posx+1)-1 ], fillColor:app.activeDocument.swatches[2] } );			posy++;			break;		case 4:			app.activeDocument.rectangles.add({geometricBounds:[yoff+5*posy+1, xoff+5*posx-4, yoff+5*(posy+1)-1, xoff+5*(posx+1)-1 ], fillColor:app.activeDocument.swatches[2] } );			posx--;			break;		case 8:			app.activeDocument.rectangles.add({geometricBounds:[yoff+5*posy+1, xoff+5*posx+1, yoff+5*(posy+1)-1, xoff+5*(posx+1)+4 ], fillColor:app.activeDocument.swatches[2] } );			posx++;			break;	}		maze[posy][posx] = true;}// As found on http://jsfromhell.com/math/is-point-in-poly// No idea what this all means :-) [fortunately, I don't have to!]function pointInside(pt, poly){    for(var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)        ((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) || (poly[j][1] <= pt[1] && pt[1] < poly[i][1]))        && (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0])        && (c = !c);    return c;}