////  MultiPrint.js версия 21////  Постраничный экспорт файлов PostScript и PDF из Adobe InDesign////  На основе MultiPrint.js Олега Бутрина <obutrin@indesign.rudtp.ru>,//  дополнено Константином Смородским <smorodsky@gmail.com>//  2016-12-01////  Последняя версия скрипта доступна по адресу://  http://sites.google.com/site/multiprintjs/////  Установка//  Скопируйте этот файл в папку://    для CS, CS2 - <Adobe InDesign Folder>/Presets/Scripts///    для CS3 и более поздних версий - <Adobe InDesign Folder>/Scripts/Scripts Panel///  Откройте палитру Scripts и дважды щелкните MultiPrint.js// ****************************************************************// $.locale = 'ru';	// принудительно включает русскую локализацию// $.locale = 'en';	// принудительно включает английскую локализациюvar langNoFiles = {	en: "No open files!",	ru: "Нет открытых файлов!"};var langChoiceFolderWithIndd = {	en: "Specify the folder with InDesign documents.",	ru: "Выберите папку содержащую документы InDesign."};var langNoDoc = {	en: "Do not have selected documents!",	ru: "Не выбрано ни одного документа!"};var langPrintSelect = {	en: "Export:",	ru: "Экспорт:"};var langExportLocked = {	en: "If the document is locked by other users:       ",	ru: "Если документ заблокирован другим пользователем:"};var langExportLockedAll = {	en: "Export",	ru: "Экспортировать"};var langExportLockedSkip = {	en: "Skip",	ru: "Пропустить"};var langExportLockedStop = {	en: "Stop",	ru: "Остановиться"};var langSelectFolder = {	en: "Choice destination folder",	ru: "Выберите основную папку для экспорта"};var langPrintStyle = "PS / Print Preset:";var langPDFStyle = "PDF / Preset:";var langJPEGStyle = "JPEG";var langFolderPattern = {	en: "Folder pattern: ",	ru: "Шаблон для папок:"};var langFilePattern = {	en: "File pattern: ",	ru: "Шаблон для файлов:"};var langCurrentBookName = {	en: " - book name",	ru: " - имя книги"};var langCurrentDocName = {	en: " - document name",	ru: " - имя документа"};var langCurrentPageNumber = {	en: " - page number",	ru: " - номер страницы"};var langCurrentMarkedText = {	en: ' - text with applied "export" style',	ru: ' - текст отмеченный стилем "export"'};var langSecPrefix = {	en: " - section prefix",	ru: " - префикс секции"};var langSecMarker = {	en: " - section marker",	ru: " - маркер секции"};var langLenFileNumber1 = {	en: "Extend page number to",	ru: "Дополнить номер страницы до"};var langLenFileNumber2 = {	en: "characters",	ru: "знаков"};var langPrintDefault = {	en: "Use default Print Preset: " + app.printerPresets[0].name + "?",	ru: "Использовать параметры печати по умолчанию: " + app.printerPresets[0].name + "?"};var langPrintDirectly = {	en: "No PPD-file. Print directy?",	ru: "Нет PPD-файла для данного Print Preset. Печатать напрямую?"};var langPageNumbers = {	en: "Pages:",	ru: "Страницы: "};var langPageNumbersSample1 = {	en: 'List of the pages, splited by commas: "1, 5-7, 9-",',	ru: 'Перечислите страницы через запятую: "1, 5-7, 9-",'};var langPageNumbersSample2 = {	en: 'or blank for export all,',	ru: 'или оставьте пустым чтобы экспортировать все,'};var langPageNumbersSample3 = {	en: 'or type "S" for export all pages in to single file.',	ru: 'или введите "S" для экспорта всех страниц в один файл.'};var langNoPageRannge = {	en: "Invalid page number: ",	ru: "Недопустимый номер страницы: \""};var langNoExportedPages = {	en: "These pages are not available or empty",	ru: "Указанные страницы отсутствуют либо пусты"};var langExportedPages = {	en: "Exported pages: ",	ru: "Экспортировано страниц: "};var langMissedPages = {	en: "Missing pages: ",	ru: "Пропущено страниц: "};var langExportedDocuments = {	en: "Exported documents: ",	ru: "Экспортировано документов: "};var langMissedDocuments = {	en: "Missing documents: ",	ru: "Пропущено документов: "};var langNoFolderPattern = {	en: "Not specified folder name",	ru: "Не указано имя папки"};var langErrNoSpace = {	en: "Out of disk space",	ru: "Недостаточно места на диске"};var langPage = {	en: "page",	ru: "страница"};var langConvertSpotsToProcess = {	en: "Convert All Spots to Process                       ",	ru: "Печатать все плашечные цвета как триадные            "};// JPEG optionsvar langJpegOptions = {	en: "JPEG options",	ru: "Параметры JPEG"};var langJpegAntiAlias = {	en: "Anti Alias",	ru: "Использовать сглаживание"};var langJpegEmbedColorProfile = {	en: "Embed Color Profile",	ru: "Встроить цветовой профиль"};var langJpegResolution = {	en: "Resolution:",	ru: "Разрешение:"};var langJpegPPI = {	en: "ppi",	ru: "ppi"};var langJpegExportingSpread = {	en: "Exporting Spread",	ru: "Экспортировать развороты"};var langJpegColorSpace = {	en: "Color Space:",	ru: "Цветовое пространство:"};var langJpegQuality = {	en: "Quality:",	ru: "Сжатие:"};var langJpegSimulateOverprint = {	en: "Simulate Overprint",	ru: "Имитировать оверпринты"};var langJpegUseDocumentBleeds = {	en: "Use Document Bleeds",	ru: "Припуск за обрез"};	if ('scriptPreferences' in app) {		if ('enableRedraw' in app.scriptPreferences) app.scriptPreferences.enableRedraw = true;	app.scriptPreferences.userInteractionLevel = UserInteractionLevels.interactWithAll;}var idVersion = Number(String(app.version).split('.')[0]);if (idVersion < 4) {	var localize = function (res) 	{		if ('Object' != res.constructor.name) return res;				// русский только в CS2 и старше		return res.en;	}}// ****************************************************************// String methods// удаляет пробельные символы в начале и в конце строкиString.prototype.trim = function(){	var whitespace = ' \n\r\t\f\x0b\xa0\u2000\u2001\u2002\u2003\\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u3000';		var str = this;		for (var i = 0, l = str.length; i < l; i++)	{		if (whitespace.indexOf(str.charAt(i)) === -1)		{			str = str.substring(i);			break;		}	}		for (i = str.length - 1; i >= 0; i--)	{		if (whitespace.indexOf(str.charAt(i)) === -1)		{			str = str.substring(0, i + 1);			break;		}	}		return whitespace.indexOf(str.charAt(0)) === -1 ? str : '';}// преобразование римских цифр в Number// возвращает NaN если преобразование невозвожноString.prototype.fromRomanNum = function(){	// знаки	var dict = [];	dict['I'] = 1;	dict['V'] = 5;	dict['X'] = 10;	dict['L'] = 50;	dict['C'] = 100;	dict['D'] = 500;	dict['M'] = 1000	var n = 0;	var v = this.trim();		// calculate value	for (var c = 0, l = v.length; c < l; c++)	{		var ltr = v.charAt(c).toUpperCase();		if (c == v.length - 1) return n + dict[ltr];		var next = v.charAt(c + 1).toUpperCase();		if ((ltr == 'I' || ltr == 'X' || ltr == 'C') && dict[ltr] < dict[next])			n -= dict[ltr];		else			n += dict[ltr];	}	return n;}// удаляет все символы после последней точки в имени файла (удаляем расширение)String.prototype.trimExtention = function(){	var myResult = this.lastIndexOf('.');	if (myResult < 0) return this;	return this.substr(0, myResult);}// замена тeгов имени файла и номера страницы на реальные значенияString.prototype.fillNamePattern = function(myBookName, myDocName, /* optional */ page){		// подставим вместо тегов значения	var myString = this.split(prefs.folderTag).join(myDocName);	myString = myString.split(prefs.bookTag).join(myBookName);	myString = myString.split(prefs.styleTag).join(styleLastValue);		var masterName = '';		if (page && page.appliedMaster && page.appliedMaster != NothingEnum.NOTHING) {				masterName = page.appliedMaster.name;		}		myString = myString.split(prefs.masterPageTag).join(masterName);		if (page) {		var pageNum = page.name;				// дополним номер страницы нулями		if (String(pageNum).length < prefs.lenFileNumber)				pageNum = ("0000" + pageNum).slice(-prefs.lenFileNumber);				myString = myString.split(prefs.pageTag).join(pageNum);				var section = page.appliedSection; 		myString = myString.split(prefs.secPrefixTag).join(section.sectionPrefix);		myString = myString.split(prefs.secMarkerTag).join(section.marker);	} else {		// singleMode - документ в один файл		myString = myString.split(prefs.pageTag).join('');		myString = myString.split(prefs.secPrefixTag).join('');		myString = myString.split(prefs.secMarkerTag).join('');	}	return myString;}//  Array methods//	By Mozilla Developer Center (http://developer.mozilla.org)if (!Array.prototype.filter) {	/**	 * Creates a new array with all elements that	 * pass the test implemented by the provided function.	 */	Array.prototype.filter = function(fun /*, thisp*/) {		var len = this.length;		if (typeof fun != "function")			throw new TypeError();		var res = new Array();		var thisp = arguments[1];		for (var i = 0; i < len; i++) {			if (i in this) {				var val = this[i]; // in case fun mutates this				if (fun.call(thisp, val, i, this))					res.push(val);			}		}		return res;	};}if (!Array.prototype.forEach) {	/**	 * Executes a provided function once per array element.	 */	Array.prototype.forEach = function(fun /*, thisp*/) {		var len = this.length;		if (typeof fun != "function")			throw new TypeError();		var thisp = arguments[1];		for (var i = 0; i < len; i++) {			if (i in this)				fun.call(thisp, this[i], i, this);		}	};}if (!Array.prototype.every) {	/**	 * Tests whether all elements in the array	 * pass the test implemented by the provided function.	 */	Array.prototype.every = function(fun /*, thisp*/) {		var len = this.length;		if (typeof fun != "function")			throw new TypeError();		var thisp = arguments[1];		for (var i = 0; i < len; i++) {			if (i in this &&					!fun.call(thisp, this[i], i, this))				return false;		}		return true;	};}if (!Array.prototype.some) {	/**	 * Tests whether some element in the array passes 	 * the test implemented by the provided function. 	 */	Array.prototype.some = function(fun /*, thisp*/) {		var len = this.length;		if (typeof fun != "function")			throw new TypeError();		var thisp = arguments[1];		for (var i = 0; i < len; i++) {			if (i in this &&					fun.call(thisp, this[i], i, this))				return true;		}		return false;	};}if (!Array.prototype.map) {	/**	 * Tests whether some element in the array passes	 * the test implemented by the provided function.	 */	Array.prototype.map = function(fun /*, thisp*/) {		var len = this.length;		if (typeof fun != "function")			throw new TypeError();		var res = new Array(len);		var thisp = arguments[1];		for (var i = 0; i < len; i++) {			if (i in this)				res[i] = fun.call(thisp, this[i], i, this);		}		return res;	};}// проверяет, находится ли страница в диапазоне печатаемыхPage.prototype.inExportedRange = function(){	// если стоит соотв. флаг	// или диапазоны не определены, то печатаем все	if (prefs.exportAllPages || !exportedPages) return true;		var pageNumberStyle = this.appliedSection.pageNumberStyle;	var arabicStyle = pageNumberStyle == PageNumberStyle.arabic;	var romanStyle = pageNumberStyle == PageNumberStyle.upperRoman				|| pageNumberStyle == PageNumberStyle.lowerRoman;		var pageNumber = arabicStyle ? Number(this.name) : String(this.name);		for (var i = 0, l = exportedPages.length; i < l; i++)	{		var n = pageNumber;		var from = exportedPages[i][0], to = exportedPages[i][1];		// если используется нумерация римскими цифрами...		if (romanStyle)		{			if (from.constructor.name.toLowerCase() == 'number') continue;						// ...переводим в числовые значения...			n = pageNumber.fromRomanNum();			from = from.fromRomanNum();			if (to) to = to.fromRomanNum();						// ...проверяем корректность...			if (isNaN(n) || isNaN(from)	|| isNaN(to)) continue;		}				// теперь сравниваем		if (arabicStyle || romanStyle)		{			if (!to && n >= from) return true;			if (to && n >= from && n <= to) return true;		}		else // если используется нумерация буквами		{			if (from.constructor.name.toLowerCase() != 'string') continue;			if (n.length < from.length) continue;			if (to && n.length > to.length) continue;			if (n.length == from.length && n < from) continue;			if (to && n.length == to.length && n > to) continue;			return true;		}	}	return false;}// возвращает текст, отмеченный указанным стилемPage.prototype.getTextWithStyle = function(styleName){	var pars = [], contents = '';		this.allPageItems.some(function(textFrame)	{		if (!('paragraphs' in textFrame)) return;				for (var i = 0, l = textFrame.paragraphs.length; i < l; i++)		{			var paragraph = textFrame.paragraphs[i];						if (paragraph.appliedParagraphStyle &&				paragraph.appliedParagraphStyle.name == styleName) {								contents = paragraph.contents;				return true;			}					}	});		return contents.replace(/[\n\r\t]/g, ' ').trim().substr(0, 50);}// prefs constructorfunction Prefs(){	// default values	this.scriptName =     "MultiPrint";	var scriptVersion =   21;	var scriptCompatibleVersion = 12;	this.exportMode =     0; // 0 - ps; 1 - pdf; 2 - jpeg	this.exportLocked =   0; // 0 - export, 1 - skip, 2 - stop	this.defPrintPreset = 0;	this.defPDFStyleNum = 0;	this.defaultFolder =  "";	this.inddFolder =     "";	this.folderTag =      "%doc%";	this.bookTag =        "%book%";	this.pageTag =        "%page%";	this.styleTag =       "%style%";	this.secPrefixTag =   "%prefix%";	this.secMarkerTag =   "%marker%";	this.masterPageTag =  "%master%";	this.folderPattern =  this.folderTag;// + '_Folder';	this.folderPatterns = [this.folderPattern];	this.filePattern =    this.folderTag + '_' + this.pageTag;	this.filePatterns =   [this.filePattern];	this.lenFileNumber =  3;	this.exportAllPages = false;	this.pageNumbers =    "";	this.convertSpotsToProcess = false;	this.singleMode = false;	this.jpegOptions_antiAlias          = true;	this.jpegOptions_embedColorProfile  = false;	this.jpegOptions_exportResolution   = 150;	this.jpegOptions_exportingSpread    = false;	this.jpegOptions_jpegColorSpace     = 1* JpegColorSpaceEnum.RGB;	this.jpegOptions_jpegQuality        = 1* JPEGOptionsQuality.MEDIUM;	this.jpegOptions_jpegRenderingStyle = 1* JPEGOptionsFormat.PROGRESSIVE_ENCODING;	this.jpegOptions_simulateOverprint  = true;	this.jpegOptions_useDocumentBleeds  = false;		// file for save preferences	// Folder.userData - undefined in CS	var fileName = (idVersion < 4 ? Folder.temp : Folder.userData) +		'/' + File.encode(this.scriptName + '.prefs');	var file = new File(fileName);	file.encoding = 'utf8';	// reading	if (file.exists)	{		try		{			file.open("r"); // open preferences file			var data = file.read(9999);			file.close();			// read values			data = eval(data);			// проверяем версию			if (this.scriptName == data.scriptName					&& Number(scriptCompatibleVersion) <= Number(data.scriptVersion))					// обновляем значения					for (var i in data) this[i] = data[i];							}		catch(e)		{			//alert(e.message);			file.close();			file.remove();		}	}	this.scriptVersion = scriptVersion;		// for compatibility with future versions having additional export options	if (this.exportMode > 2) {		this.exportMode = 0;	}		// save preferences	this.save = function()	{		var savedObject = {};		for (var i in this)		{			switch (this[i].constructor.name.toLowerCase())			{				case 'function':					continue; // програмный код не сохраняем								case 'file':	// для этих объектов				case 'folder':	// сохраняем только путь					savedObject[i] = this[i].fsName;					break;									default:					savedObject[i] = this[i];			}		}				// сохраняем файл настроек		file.open("w");		file.write(savedObject.toSource());		file.close();	}}var prefs = new Prefs();// конструктор объекта progressbarfunction ProgressBar(caption){	var t = this;	var compatibleIDVersion = Number(String(app.version).split('.')[0]) >= 5;	var myProgressPanel;	var myProgressInfo;	var myProgressBar, myStatus;	var myValue = 0;	var myIncrement = 0;			if (compatibleIDVersion)	{		myProgressPanel = new Window('palette', caption);		myProgressBar = myProgressPanel.add('progressbar',			{x:10, y:12, width:350, height:12}, 0, 99);		myStatus = myProgressPanel.add('statictext',			{x:10, y:36, width:350, height:20}, '');	}		this.increment = function(inc) // устанавливает приращение	{		if (inc >= 0) myIncrement = inc;	}		this.status = function(msg)	{		if (!compatibleIDVersion) return;		 myStatus.text = msg;	}		// устанавлиает новое значение или делает 1 шаг	this.step = function(/* optional */ v, msg)	{		if (!compatibleIDVersion) return;				if (typeof v == 'undefined') myValue += myIncrement;		else myValue = v;				if (myValue >= 99)		{			// завершение: прячем окошко			myProgressPanel.hide();			return;			}		myProgressPanel.show();		myProgressBar.value = myValue;				if (typeof msg != 'undefined')		{			this.status(msg);		}	}}var progressBar = new ProgressBar(prefs.scriptName + prefs.scriptVersion);// Doc constructorfunction Doc(obj, book){	var		document = null,		fullName = null;		switch (obj.constructor.name)	{		case 'Document':			document = obj;			this.name = document.name;			break;				case 'BookContent':			fullName = File.decode(obj.fullName);			this.name = (new File(obj.fullName)).name;						// поищем документ среди уже открытых			for (var i = app.documents.length; i--;)			{				if (!app.documents[i].saved) continue;				if (app.documents[i].fullName == obj.fullName)				{					document = app.documents[i];					break;				}			}			break;				case 'File':			fullName = obj.fsName;			this.name = obj.name;			break;					case 'Folder':			break;					default:			throw 'Bad document (' + obj.constructor.name + ')';	}	this.name = File.decode(this.name);		var bookName = book ? String(File.decode(book.name)).trimExtention() : '';		//-- getters	this.getDocument = function()	{		if (document) return document;				// откроем документ если он закрыт		try 		{			var file = new File(File.encode(fullName));			document = app.open(file, false);		}		catch (e) {			var msg = e.message;						// неизвестная ошибка			// или останов на заблокированных			if (e.number != 90881 || 2 == prefs.exportLocked) 			{				alert(msg);				return null;			}					// опция "пропускать заблокированные"			if (1 == prefs.exportLocked) return null;						// если документ заблокирован			// сделаем его копию и откроем ее			this.tempFile = new File(file.parent.absoluteURI +				'/~' + (new Date()).getTime().toString(36) + file.name);						if (this.tempFile.exists || !file.copy(this.tempFile)) 			{				alert(msg);				exit();			}			try 			{				document = app.open(this.tempFile, false);			}			catch (e) 			{				alert(e.message);				exit();			}		}		return document;	}		this.getFullName = function()	{		if (fullName) return fullName;		return document.saved ? document.fullName.fsName : document.name;	}		this.getBook = function()	{		return book;	}		this.getBookName = function()	{		return bookName;	}}function ExportPage(document, /* optional */ page) {		if (page) 	{		var pageName = page.name;				// вычисляем номер страницы. если нужно, то с учетом секции		var exportRange = page.appliedSection.includeSectionPrefix ?			pageName : (page.appliedSection.name + pageName);	}	else 	{		var pageName = document.pages[0].name;		var exportRange = PageRange.allPages;	}		var documentName = document.name;		if (prefs.defaultFolder) { // печать в файл		var exportFolder = new Folder(Folder.encode(prefs.defaultFolder));				// Если включена опция создания раздельных папок		if (prefs.folderPattern)		{			var newFolder = prefs.folderPattern.fillNamePattern(					bookName, documentName, page);						if (newFolder.length)			{				newFolder = new Folder(exportFolder.absoluteURI + "/" + Folder.encode(newFolder));								// Проверяем наличие или создаем папку				if (newFolder.exists || newFolder.create()) exportFolder = newFolder;			}		}		// файл для экспорта этой страницы		var myPrintFile = new File(exportFolder.absoluteURI + "/" + File.encode(			prefs.filePattern.fillNamePattern(bookName, documentName, page)));	}		try	{		switch (prefs.exportMode)		{			// Если печать			case 0:				// если печать разворотами, то печатаем только левую страницу				if (!prefs.singleMode && myPrinter.printSpreads && page.index) {					return false;				}								if (prefs.defaultFolder) {					myPrinter.printFile = myPrintFile;				}				//Определяем диапазон печати				document.printPreferences.pageRange = exportRange;								// Печатаем страницу				// здесь возможно исключение в случае, когда страницa пустая,				// а выбранный Print Preset не допускает печать пустых страниц				document.print(false, myPrinter);				break;							// Если выбран стиль экспорта в PDF			case 1:								// если экспорт разворотами, то только экспортируем только первую страницу				if (!prefs.singleMode && pdfPreset.exportReaderSpreads && page.index) {					return false;				}								app.pdfExportPreferences.pageRange = exportRange;								// Экспортируем				if (idVersion < 7) { // младше CS5					document.exportFile(						ExportFormat.pdfType,						myPrintFile,						false,						pdfPreset					);				} 				else {					// асинхронный экспорт для избежания ошибки					// с экспортом прилинкованных PDF-файлов					var task = document.asynchronousExportFile(						ExportFormat.PDF_TYPE,						myPrintFile,						false,						pdfPreset					);					task.waitForTask();				}				break;						// Если выбран стиль экспорта в JPEG			case 2:				// если экспорт разворотами, то только экспортируем только первую страницу				if (prefs.jpegOptions_exportingSpread && page.index) {					return false;				}								app.jpegExportPreferences.pageString = exportRange;								var task = document.exportFile(					ExportFormat.JPG,					myPrintFile,					false				);				break;		}	}	catch(e)	{		myPrintFile && myPrintFile.remove();		newFolder && newFolder.remove();				missedPages.push(pageName);				switch (e.number)		{			case 30522:// страницa пустая			case 90892: 			//case 7181: // Unable to read JPEG				return false;						case 2589:  // недостаточно места на диске				errorMsg = localize(langErrNoSpace);				return false;						default:				errorMsg = e.description + " (" + e.number + "  line:" + e.line + ")";				return false;		}	}	return true;}function askJpegExportOptions() {		if (idVersion < 7) {		return;	}		var dialog = new Window("dialog", 'MultiPrint - ' + localize(langJpegOptions));    dialog.orientation =   "row";    dialog.alignChildren = "top";        var mainGroup = dialog.add("panel");    mainGroup.alignChildren = "fill";    mainGroup.orientation =   "column";		var grpColorSpace = mainGroup.add("group");	grpColorSpace.orientation = "row";		grpColorSpace.add ("statictext", undefined, localize(langJpegColorSpace));	var jpegColorSpace = grpColorSpace.add ("DropDownList", undefined, ['RGB', 'CMYK', 'Gray']);		switch (prefs.jpegOptions_jpegColorSpace) {				case JpegColorSpaceEnum.RGB:			jpegColorSpace.selection = jpegColorSpace.find('RGB');			break;					case JpegColorSpaceEnum.CMYK: 			jpegColorSpace.selection = jpegColorSpace.find('CMYK');			break;					case JpegColorSpaceEnum.GRAY: 			jpegColorSpace.selection = jpegColorSpace.find('Gray');			break;	}		var grpResolution = mainGroup.add("group");	grpResolution.orientation = "row";	grpResolution.add ("statictext", undefined, localize(langJpegResolution));	var exportResolution = grpResolution.add("EditText", undefined, prefs.jpegOptions_exportResolution);	exportResolution.minimumSize = {width: 50, height: 9};	grpResolution.add ("statictext", undefined, localize(langJpegPPI));		exportResolution.onChanging = function() {				var n = parseFloat(exportResolution.text);		okButton.enabled = !(isNaN(n) || n < 1 || n > 2400);	}		var grpQuality = mainGroup.add("group");	grpQuality.orientation = "row";		grpQuality.add ("statictext", undefined, localize(langJpegQuality));	var jpegQuality = grpQuality.add ("DropDownList", undefined, ['Low', 'Medium', 'High', 'Maximum']);		switch (prefs.jpegOptions_jpegQuality) {				case JPEGOptionsQuality.LOW:			jpegQuality.selection = jpegQuality.find('Low');			break;					case JPEGOptionsQuality.MEDIUM: 			jpegQuality.selection = jpegQuality.find('Medium');			break;				case JPEGOptionsQuality.HIGH: 			jpegQuality.selection = jpegQuality.find('High');			break;				case JPEGOptionsQuality.MAXIMUM: 			jpegQuality.selection = jpegQuality.find('Maximum');			break;	}			var antiAlias = mainGroup.add ("checkbox", undefined, localize(langJpegAntiAlias)); //cs6+	antiAlias.value = prefs.jpegOptions_antiAlias;	var embedColorProfile = mainGroup.add ("checkbox", undefined, localize(langJpegEmbedColorProfile)); //cs6+	embedColorProfile.value = prefs.jpegOptions_embedColorProfile;	var exportingSpread = mainGroup.add ("checkbox", undefined, localize(langJpegExportingSpread));	exportingSpread.value = prefs.jpegOptions_exportingSpread;	var simulateOverprint = mainGroup.add ("checkbox", undefined, localize(langJpegSimulateOverprint)); //cs6+	simulateOverprint.value = prefs.jpegOptions_simulateOverprint;	var useDocumentBleeds = mainGroup.add ("checkbox", undefined, localize(langJpegUseDocumentBleeds)); //cs6+	useDocumentBleeds.value = prefs.jpegOptions_useDocumentBleeds;	// buttons    var buttonGroup = dialog.add ("group");    buttonGroup.alignChildren = "fill";    buttonGroup.orientation = "column";        var okButton = buttonGroup.add ("button", undefined, "OK", {name: "ok"});	var okCancel = buttonGroup.add ("button", undefined, "Cancel", {name: "cancel"});		if (2 == dialog.show()) {					exit();	}	// update prefs	var res = parseFloat(exportResolution.text);		if (isNaN(res)) {		exit();	}	prefs.jpegOptions_exportResolution = res;		switch (jpegColorSpace.selection.text) {				case 'RGB':			prefs.jpegOptions_jpegColorSpace = 1* JpegColorSpaceEnum.RGB;			break;					case 'CMYK':			prefs.jpegOptions_jpegColorSpace = 1* JpegColorSpaceEnum.CMYK;			break;					case 'Gray':			prefs.jpegOptions_jpegColorSpace = 1* JpegColorSpaceEnum.GRAY;			break;	}		switch (jpegQuality.selection.text) {				case 'Low':			prefs.jpegOptions_jpegQuality = 1* JPEGOptionsQuality.LOW;			break;				case 'Medium':			prefs.jpegOptions_jpegQuality = 1* JPEGOptionsQuality.MEDIUM;			break;					case 'High':			prefs.jpegOptions_jpegQuality = 1* JPEGOptionsQuality.HIGH;			break;				case 'Maximum':			prefs.jpegOptions_jpegQuality = 1* JPEGOptionsQuality.MAXIMUM;			break;	}		prefs.jpegOptions_antiAlias = antiAlias.value;	prefs.jpegOptions_embedColorProfile = embedColorProfile.value;	prefs.jpegOptions_exportingSpread = exportingSpread.value;	prefs.jpegOptions_simulateOverprint = simulateOverprint.value;	prefs.jpegOptions_useDocumentBleeds = useDocumentBleeds.value;		// update app.jpegExportPreferences	for (var i in prefs) {				if (i.indexOf('jpegOptions_') != 0) {						continue;		}		var key = i.split('_')[1];				app.jpegExportPreferences[key] = prefs[i];	}	app.jpegExportPreferences.jpegExportRange = ExportRangeOrAllPages.EXPORT_RANGE;}// *********************************************************************// читаем все документы из всех открытых книгvar	docs = [],	docsGroups = [],	docsGroup = [];$.sleep(400); // задержка чтобы успеть нажать клавишуvar shiftPressed = typeof ScriptUI == 'function' ?	ScriptUI.environment.keyboardState.shiftKey : false;for (var i = 0, l = app.books.length; i < l; i++){	var book = app.books[i];	var bookLength = book.bookContents.length;		if (bookLength)	{		for (var j = 0; j < bookLength; j++)		{			var doc = new Doc(book.bookContents[j], book);			docs.push(doc);			docsGroup.push(doc);		}		docsGroups.push(docsGroup);		docsGroup = [];	}}// добавим все открытые документыfor (var i = 0, l = app.documents.length; i < l; i++){	var document = app.documents[i];		// только документы имеющие окна	if (document.windows.length == 0) continue;		try	{		var fullName = (new File(File.encode(document.fullName))).fsName;	}	catch (e)	{		var fullName = String(document.name);	}		// проверим, не был ли уже добавлен этот документ	if (docs.some(function(d){return fullName == d.getFullName()})) continue;		// добавляем новый doc	var doc = new Doc(document);	docs.push(doc);	docsGroup.push(doc);}if (docsGroup.length) docsGroups.push(docsGroup);// если нет документов - предложим выбрать папкуif (!docsGroups.length){	var xFolder = Folder.selectDialog(localize(langChoiceFolderWithIndd), prefs.inddFolder);		if (!xFolder) exit();	prefs.inddFolder = xFolder.fsName;		// browse subfolders	(function(folder) {				var files = folder.getFiles('*.indd');				for (var i = files.length; i--; )		{			if (files[i] instanceof File)			{				var doc = new Doc(files[i]);				docs.push(doc);				docsGroup.push(doc);			}		}		if (docsGroup.length) {			docsGroups.push(docsGroup);			docsGroup = [];		}				// subfolders seek		var folders = folder.getFiles(function(f){			return f.name[0] != '.' && (f instanceof Folder);});				for (var i = folders.length; i--; )		{			arguments.callee(folders[i]);		}	})(xFolder);}// если нет документов - выходif (!docsGroups.length) {alert(localize(langNoFiles)); exit();}// Создаем диалогvar myDialog = app.dialogs.add({name:prefs.scriptName + prefs.scriptVersion, width: 1555})// панели со списками документовfor (var i = 0, l = docsGroups.length; i < l; i++){	docsGroup = docsGroups[i];	dgLength = docsGroup.length;	if (dgLength)	{		with (myDialog.dialogColumns.add())		{			with (borderPanels.add().dialogColumns.add())			{				var book = docsGroup[0].getBook();								if (book)				{					dialogRows.add().staticTexts.add({staticLabel: book.name});				}							with (borderPanels.add().dialogColumns.add())				{					var checkBoxes = [];					for (var j = 0; j < dgLength; j++)					{						var doc = docsGroup[j];												doc.check = checkboxControls.add({							staticLabel: doc.name, checkedState: !shiftPressed});												checkBoxes.push(doc.check);					}				}			}		}	}}// параметры экспортаwith (myDialog.dialogColumns.add()){	// стили	with (borderPanels.add().dialogColumns.add())	{		dialogRows.add().staticTexts.add({staticLabel: localize(langPrintSelect)});		with (dialogRows.add())		{			var rbExportMode = radiobuttonGroups.add();			with (dialogColumns.add())			{				rbExportMode.radiobuttonControls.add({staticLabel: '', checkedState: prefs.exportMode == 0});				rbExportMode.radiobuttonControls.add({staticLabel: '', checkedState: prefs.exportMode == 1});				if (idVersion >= 7) {					rbExportMode.radiobuttonControls.add({staticLabel: '', checkedState: prefs.exportMode == 2});				}			}			with (dialogColumns.add())			{				dialogRows.add().staticTexts.add({staticLabel: localize(langPrintStyle)});				dialogRows.add().staticTexts.add({staticLabel: localize(langPDFStyle)});				if (idVersion >= 7) {					dialogRows.add().staticTexts.add({staticLabel: localize(langJPEGStyle)});				}			}			with (dialogColumns.add())			{				var printerPresets = app.printerPresets.everyItem().name;				var pdfExportPresets = app.pdfExportPresets.everyItem().name;								if (printerPresets.constructor.name == 'String') {					printerPresets = [printerPresets];				}				if (pdfExportPresets.constructor.name == 'String') {					pdfExportPresets = [pdfExportPresets];				}				var ddPrinterPresSelect = dropdowns.add({					stringList: printerPresets,					selectedIndex: prefs.defPrintPreset,					minWidth: 173});				var ddPDFPresSelect = dropdowns.add({					stringList: pdfExportPresets,					selectedIndex: prefs.defPDFStyleNum,					minWidth: 173});			}		}	}		// страницы	with (borderPanels.add().dialogColumns.add())	{		with (dialogRows.add())		{			dialogColumns.add().dialogRows.add().staticTexts.add({staticLabel: localize(langPageNumbers)});			pageNumbers = dialogColumns.add().dialogRows.add().textEditboxes.add({editContents: prefs.pageNumbers, minWidth: 254})		}		// подсказка		dialogRows.add().staticTexts.add({staticLabel: localize(langPageNumbersSample1)});		dialogRows.add().staticTexts.add({staticLabel: localize(langPageNumbersSample2)});		dialogRows.add().staticTexts.add({staticLabel: localize(langPageNumbersSample3)});	}	// шаблоны	with (borderPanels.add().dialogColumns.add())	{		with (dialogRows.add())		{			with (dialogColumns.add())			{				dialogRows.add().staticTexts.add({staticLabel: localize(langFolderPattern)});				dialogRows.add().staticTexts.add({staticLabel: localize(langFilePattern)});			}			with (dialogColumns.add())			{				// шаблоны имени папки				var tbFolderPattern = dialogRows.add().textEditboxes.add({					editContents: prefs.folderPattern, minWidth: 190})								// шаблоны имени файла				var tbFilePattern = dialogRows.add().textEditboxes.add({					editContents: prefs.filePattern, minWidth: 190});			}		}		with (dialogRows.add()) // дополнить номер		{			dialogColumns.add().dialogRows.add().staticTexts.add({				staticLabel: localize(langLenFileNumber1)});						var myLenFileNumber = dialogColumns.add().integerComboboxes.add({				editValue: prefs.lenFileNumber,				minimumValue: 1,				maximumValue: 5,				smallNudge: 1,				largeNudge: 1,				stringList: ["1", "2", "3", "4", "5"]});						dialogColumns.add().dialogRows.add().staticTexts.add({				staticLabel: localize(langLenFileNumber2)});		}		// подсказки		dialogRows.add().staticTexts.add({staticLabel: prefs.pageTag       + localize(langCurrentPageNumber)});		dialogRows.add().staticTexts.add({staticLabel: prefs.secPrefixTag  + localize(langSecPrefix)});		dialogRows.add().staticTexts.add({staticLabel: prefs.secMarkerTag  + localize(langSecMarker)});		dialogRows.add().staticTexts.add({staticLabel: prefs.folderTag     + localize(langCurrentDocName)});		dialogRows.add().staticTexts.add({staticLabel: prefs.bookTag       + localize(langCurrentBookName)});		dialogRows.add().staticTexts.add({staticLabel: prefs.styleTag      + localize(langCurrentMarkedText)});	}	// заблокированные документы	with (borderPanels.add().dialogColumns.add())	{		dialogRows.add().staticTexts.add({staticLabel: localize(langExportLocked)});				with (dialogRows.add())		{			var rbExportLocked = radiobuttonGroups.add();						with (dialogColumns.add())			{				rbExportLocked.radiobuttonControls.add({					staticLabel: localize(langExportLockedAll),					checkedState: !prefs.exportLocked});				rbExportLocked.radiobuttonControls.add({					staticLabel: localize(langExportLockedSkip),					checkedState: 1 == prefs.exportLocked});				rbExportLocked.radiobuttonControls.add({					staticLabel: localize(langExportLockedStop),					checkedState: 2 == prefs.exportLocked});			}		}	}	with (borderPanels.add().dialogColumns.add())	{		var chkConvertSpots = dialogRows.add().checkboxControls.add({				staticLabel: localize(langConvertSpotsToProcess), checkedState: !!prefs.convertSpotsToProcess});	}}// запускаем диалогvar fl = true;while (fl){	fl = false;		// показываем	if (!myDialog.show()) 	{		// если нажата кнопка отмены - выход		//myDialog.destroy();		exit();	}		// проверим поле номеров страниц	var ranges = String(pageNumbers.editContents).trim().replace('*', '');	prefs.exportAllPages = ranges.length == 0;		// режим экспорта в один файл	prefs.singleMode = ranges.toUpperCase() == 'S';		// Проверяем шаблон имен файлов	prefs.filePattern = String(tbFilePattern.editContents).trim();		// проверим, выбран ли стиль печати		if (!rbExportMode.selectedButton)	{		if (ddPrinterPresSelect.selectedIndex == 0 && !confirm(localize(langPrintDefault)))		{			fl = true;			continue;		}				var myPrinter = app.printerPresets[ddPrinterPresSelect.selectedIndex];		//Пробуем найти ppd		try		{			myPrinter.ppd;		}		catch (e)		{			// Если его нет, то предлагаем напечетать напрямую на принтер			if (!confirm(localize(langPrintDirectly))) continue;		}	}		if (fl) continue;	// если указано печатать НЕ все страницы	if (!prefs.singleMode && !prefs.exportAllPages)	{		// массив c диапазонами номеров печатаемых страниц		var exportedPages = [];				ranges = ranges.split(/[\n\r\t ,]/g);		for (var i = 0, l = ranges.length; i < l; i++)		{			var range = ranges[i];			if (range == '') continue;						// границы диапазона			if (range.search(/-/) >= 0) range = range.split('-')			else range = [range, range];						for (var j = 0; j <= 1; j++)			{				// пытаемся преобразовать в числовые значения, если ошибка оставляем текстом				// parseFloat необходим для корректной обработки номеров вида 007				var pg = parseInt(parseFloat(range[j]));				if (!isNaN(pg)) range[j] = pg;				else				{					// граница диапазона в смешаном регистре					fl = fl || (range[j].toUpperCase() != range[j] &&						range[j].toLowerCase() != range[j]);										// недопустимые символы в границах диапазона					fl = fl || (range[j].search(/[^a-zA-Z0-9]+/) >= 0);										// смешаные буквы и цифры					fl = fl || (range[j].search(/[0-9]/) >= 0);				}			}			// не указано начало диапазона			fl = fl || (range[0] == '');						// если указан диапазон сверяем типы начала и конца			fl = fl || (range[1] != '' && typeof(range[0]) != typeof(range[1]));			if (fl)			{				// выводим предупреждение...				alert (localize(langNoPageRannge) + ranges[i] + '"');				// ...и снова показываем диалог				break;			}			exportedPages.push(range);		}	}}// уберем из docs НЕотмеченные документыdocs = docs.filter(function(i){return i.check.checkedState});// проверяем, выбран хотя бы один документif (!docs.length){	alert(localize(langNoDoc));	myDialog.destroy();	exit();}// сохраняем настройкиif (prefs.exportAllPages || prefs.singleMode) {	prefs.pageNumbers = String(pageNumbers.editContents);}else {	// "красивый" список экспортируемых страниц	prefs.pageNumbers = exportedPages.map(		function(i)		{			var from = i[0], to = i[1];			return (from == to) ? from : from + '-' + to;		}).join(', ');}prefs.exportMode =            rbExportMode.selectedButton;prefs.exportLocked =          rbExportLocked.selectedButton;prefs.defPrintPreset =        ddPrinterPresSelect.selectedIndex;prefs.defPDFStyleNum =        ddPDFPresSelect.selectedIndex;prefs.folderPattern =         String(tbFolderPattern.editContents).trim();prefs.lenFileNumber =         Number(myLenFileNumber.editContents);prefs.convertSpotsToProcess = chkConvertSpots.checkedState;switch (prefs.exportMode) {	// PS	case 0:		var extention = '.ps';		break;			// PDF	case 1:		var extention = '.pdf';		app.pdfExportPreferences.viewPDF = false; // If true, open the PDF file after exporting		break;			// JPEG	case 2:		var extention = '.jpeg';		askJpegExportOptions();		break;}// диалог выбора корневой папкиif (prefs.exportMode > 0 || Printer.postscriptFile == myPrinter.printer) { // печать в файл		var defFolder = prefs.defaultFolder ? new Folder(Folder.encode(prefs.defaultFolder)) : Folder.myDocuments;	prefs.defaultFolder = Folder.selectDialog(localize(langSelectFolder), defFolder);		if (prefs.defaultFolder == null) {		exit(); // user canceled	}	prefs.defaultFolder = prefs.defaultFolder.fsName;	} else { // печать на принтер	prefs.defaultFolder = "";}prefs.save();// диалог больше не нуженmyDialog.destroy();// флаг использования абзацного стиля "Export"var useStylePattern = prefs.folderPattern.indexOf(prefs.styleTag) >=0 ||	prefs.filePattern.indexOf(prefs.styleTag) >= 0;// дополняем шаблон имени файла, если это необходимоif (extention != prefs.filePattern.substr(-extention.length).toLowerCase())	prefs.filePattern += extention;var	printedPages = [],          // счетчик записаных полос	missedPages = [],           // счетчик пропущеных полос	printedDocuments = [],      // счетчик экспортированных документов	missedDocuments = [],       // счетчик пропущеных документов	exportedDocumentsFn = '\n', // список всех экспортированных документов	errorMsg = false,           // сообщение о критической ошибке	pdfPreset = app.pdfExportPresets.item(prefs.defPDFStyleNum);// Для каждого документаfor (var i = 0, docsLength = docs.length; i < docsLength && !errorMsg; i++){	var doc = docs[i];	var document = doc.getDocument();		// skip locked	if (!document) continue;		// возможно, этот документ уже экспортировался	if (document.saved) {		if (exportedDocumentsFn.indexOf('\n' + document.fullName.fsName + '\n') >= 0) {			continue;		}		exportedDocumentsFn += document.fullName.fsName + '\n';	}		doc.undoHistoryLength = null;	if ('undoHistory' in document) 	{		doc.undoHistoryLength = document.undoHistory.length;	}	// All Spot to Process	document.inks.everyItem().convertToProcess = prefs.convertSpotsToProcess;		var pagesLength = document.pages.length;	var documentName = String(doc.name).trimExtention();	var bookName = doc.getBookName();			// вычисляем приращение прогресcбара	progressBar.increment(98.8 / docsLength / pagesLength);	progressBar.status(doc.name);		var styleLastValue = '';		if (prefs.singleMode) 	{		// найдем текст отмеченный стилем "export"		styleLastValue = useStylePattern && document.pages[0].getTextWithStyle('export') || styleLastValue;				if (ExportPage(document)) {			printedDocuments.push(document.name);		}		else		{			missedDocuments.push(document.name);		}	}	// Для каждой страницы текущего документа	for (var j = 0; j < pagesLength && !errorMsg; j++)	{		var page = document.pages[j];		var pageName = page.name;		var newFolder = false;				// сдвинем градусник прогрессбара		progressBar.step();				if (prefs.singleMode) continue;				// проверяем находится ли эта страница в диапазоне указанном пельзователем		if (!page.inExportedRange()) continue;				// найдем текст отмеченный стилем "export"		styleLastValue = useStylePattern && page.getTextWithStyle('export') || styleLastValue;				// обновляем progressBar		progressBar.status(doc.name + ', ' + localize(langPage) + ' ' + pageName);				if (ExportPage(document, page)) printedPages.push(pageName);;	}	// закрываем документ, если он не был открыт перед запуском скрипта	if (!document.visible)	{		document.close(SaveOptions.no);	} 	else if (doc.undoHistoryLength !== null) 	{		// иначе отменим проделанные изменения		while (document.undoHistory.length > doc.undoHistoryLength) 		{			document.undo();		}	}	// удалим временный файл	doc.tempFile && doc.tempFile.remove();}// скрываем прогресбарprogressBar.step(99);// сообщаем о завершенииif (errorMsg){	alert (localize(errorMsg));	exit();}if (prefs.singleMode) {		// выводим сообщение о завершении	var msg = localize(langExportedDocuments) + printedDocuments.length;		// если были пропущены документы, то сообщим о них	if (missedDocuments.length > 0)	{		msg += "\n\n" + localize(langMissedDocuments) +			missedDocuments.length + ":\n" + missedDocuments.join("\n");	}	alert (msg);	exit();}if (!printedPages.length){	alert (localize(langNoExportedPages));}else{	    // выводим сообщение о завершении	var msg = localize(langExportedPages) + printedPages.length + "\n" + printedPages.join(", ");;		// если были пропущены страницы, то сообщим о них	if (missedPages.length > 0)	{		msg += "\n\n" + localize(langMissedPages) +			missedPages.length + "\n" + missedPages.join("\t") + "";	}	alert (msg);}